syntax = "proto3";

package command;

service OrganisationDev {
  /// create s a new peerset with a set of peers.
  rpc CreatePeerset (CreatePeersetRequest) returns (CreatePeersetResponse) {}

  // notify peer that a new peerset has been created,
  rpc PeersetCreated (PeersetCreatedRequest) returns (PeersetCreatedResponse) {}

  // triggers process of proposing a change to the permission graph.
  rpc ProposeChange (ProposeChangeRequest) returns (ProposeChangeResponse) {}

  // verification: just read the graph
  rpc QueryPeersetsCID (QueryPeersetsCIDsRequest) returns (QueryPeersetsCIDsResponse) {}
}

message QueryPeersetsCIDsRequest { }
message QueryPeersetsCIDsResponse { }

/// Step 0.
/// Prepare a script that runs two peers in different panes on tmux, should be helpful.

/// Let's start with creating a script that runs

/// First step (Wednesday)
/// 1. create peerset:
///     - coordinator: selects one peer to create peerset smart contract
///     - peer: deploys smart contract with a set of peers
//      - coordinator: sends events to peers that they're now part of a given peerset
///     - each peer: subscribes to peerset smart contract
/// 2. propose a change,
/// 3. verify that a change has been applied and all peers see a new graph:
///   - just read the graph or its version from every peer and make sure that they see the same thing.


// Important part: connect to blockchain and listen to events.
// IPFS: not so important, skip that if necessary!

// Impl Detail:
// - how do peers find that they've been asked to be part of a given peerset?
// - another smart-contract which they need to monitor?
// - (TODO: for now just send an event that a peerset has been created)


/// Future work:
/// Answering DAC queries:
/// - bottom line: model should be as scrappy as possible but we need that for verification!

/// Peerset creation details:
/// - every peer needs to agree to be part of a given peerset, before creating a peerset.

/// Q: voting part
/// Just say yes to all changes (skip verification for now)


message CreatePeersetRequest {
  string name = 1;
  repeated string peers = 2;
  PermissionGraph initial_permission_graph = 3;
}

message CreatePeersetResponse {
  string deployed_peerset_smart_contract_address = 1;
}



message PeersetCreatedRequest {
  string deployed_peerset_smart_contract_address = 1;
}

message PeersetCreatedResponse {}


message ProposeChangeRequest {
  string peerset_address = 1;
  PermissionGraph new_permission_graph = 2;
}

message ProposeChangeResponse {
  string proposed_change_id = 1;
}


message PermissionGraph {
  map<string, Edges> edges = 1;
}

message Edges {
  Node source = 1;
  repeated Edge edges = 2;
}

message Node {
  string id = 1;
  NodeType type = 2;
  // needed for entities managed by different peersets.
  optional string peerset_address = 3;
}

enum NodeType {
  USER = 0;
  GROUP = 1;
  ASSET = 2;
}

message Edge {
  string destination_node_id = 1;
  // todo: this should probably be something more sophisticated for now let's just make it a string.
  string permission = 2;
}
