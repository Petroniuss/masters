syntax = "proto3";

package command;

service OrganisationDev {
  /// create s a new peerset with a set of peers.
  rpc CreatePeerset (CreatePeersetRequest) returns (CreatePeersetResponse) {}

  // notify peer that a new peerset has been created,
  rpc PeersetCreated (PeersetCreatedRequest) returns (PeersetCreatedResponse) {}

  // triggers process of proposing a change to the permission graph.
  rpc ProposeChange (ProposeChangeRequest) returns (ProposeChangeResponse) {}

  // triggers process of proposing a cross-peerset change.
  rpc ProposeCrossPeersetChange (ProposeCrossPeersetChangeRequest) returns (ProposeCrossPeersetChangeResponse) {}

  // verification: just read the graph
  rpc QueryPeersetsCID (QueryPeersetsCIDsRequest) returns (QueryPeersetsCIDsResponse) {}
}

message QueryPeersetsCIDsRequest { }

message QueryPeersetsCIDsResponse {
  repeated PeersetGraph peerset_graphs = 1;
}

message PeersetGraph {
  string peerset_address = 1;
  string permission_graph_cid = 2;
}

/// Next steps:
/// 1.E2E
/// crate an integration test that runs multiple containers
/// peers on containers.

/// 2. IPFS
/// - this should be easy (1-2hours)

/// 3. Atomic Commitment
/// - complete atomic commitment.
/// SC per each change
/// if we decide to use a single peerset smart contract
/// what are cons of using single smart contract per peerset
/// vs smart contract per each cross-peerset change.


/// Conference paper
/// 20.05 deadline for conference paper
/// 29.09


/// Step 0.
/// Prepare a script that runs two peers in different panes on tmux, should be helpful.

/// Let's start with creating a script that runs

/// First step (Wednesday)
/// 1. create peerset:
///     - coordinator: selects one peer to create peerset smart contract
///     - peer: deploys smart contract with a set of peers
//      - coordinator: sends events to peers that they're now part of a given peerset
///     - each peer: subscribes to peerset smart contract
/// 2. propose a change,
/// 3. verify that a change has been applied and all peers see a new graph:
///   - just read the graph or its version from every peer and make sure that they see the same thing.

/// todo:
/// - vote for a change and finish RPC after voting.. Done!
/// - for now one has to first deploy oracle smart contract (remove it!) Done!
/// - decide whether we want to keep the oracle for registering peersets or not.

///
/// - cleanup the code, otherwise it's going to be a mess.
/// - implement IPFS


// Important part: connect to blockchain and listen to events.
// IPFS: not so important, skip that if necessary!

// Impl Detail:
// - how do peers find that they've been asked to be part of a given peerset?
// - another smart-contract which they need to monitor?
// - (TODO: for now just send an event that a peerset has been created)


/// Future work:
/// Answering DAC queries:
/// - bottom line: model should be as scrappy as possible but we need that for verification!

/// Peerset creation details:
/// - every peer needs to agree to be part of a given peerset, before creating a peerset.

/// Q: voting part
/// Just say yes to all changes (skip verification for now)


message CreatePeersetRequest {
  string name = 1;
  repeated string peers = 2;
  PermissionGraph initial_permission_graph = 3;
}

message CreatePeersetResponse {
  string cid = 1;
  string deployed_peerset_smart_contract_address = 2;
}



message PeersetCreatedRequest {
  string deployed_peerset_smart_contract_address = 1;
  string permission_graph_cid = 2;
  repeated string peers = 3;
}

message PeersetCreatedResponse {}


message ProposeChangeRequest {
  string peerset_address = 1;
  PermissionGraph new_permission_graph = 2;
}

message ProposeCrossPeersetChangeRequest {
  string peerset_address = 1;
  PermissionGraph new_permission_graph = 2;
  string other_peerset_address = 3;
  PermissionGraph other_permission_graph = 4;
}

message ProposeCrossPeersetChangeResponse {
  string proposed_cid = 1;
  string other_proposed_cid = 2;
  bool accepted = 3;
}

message ProposeChangeResponse {
  string proposed_cid = 1;
  bool accepted = 2;
}


message PermissionGraph {
  map<string, Edges> edges = 1;
}

message Edges {
  Node source = 1;
  repeated Edge edges = 2;
}

message Node {
  string id = 1;
  NodeType type = 2;
  // needed for entities managed by different peersets.
  optional string peerset_address = 3;
}

enum NodeType {
  USER = 0;
  GROUP = 1;
  ASSET = 2;
}

message Edge {
  string destination_node_id = 1;
  // todo: this should probably be something more sophisticated for now let's just make it a string.
  string permission = 2;
}
